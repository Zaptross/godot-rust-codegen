use lazy_static::lazy_static;
use regex::Regex;
use std::{collections::HashMap, fs, io::Write, path::Path};

use crate::utils::to_resource_path;

// Scan Rust source files for icon comments and download/apply icons to the .gdextension file
//
// NOTE: does not add to the mod.rs
pub fn apply_icons_from_comments(
    source_code: &str,
    resource_path: &str,
    gdextension_path: &str,
    icon_sources: &std::collections::HashMap<String, String>,
) {
    lazy_static! {
        static ref ICON_COMMENT_REGEX: Regex = Regex::new(r#"zgrcg:icon="(.*?)""#).unwrap();
        static ref ICON_CLASS_REGEX: Regex = Regex::new(r#"pub struct (\w+)"#).unwrap();
        static ref ICONS_SECTION_REGEX: Regex = Regex::new(
            r#"(?m)(?:; zgrcg - autogenerated icons from comments\r?\n)?\[icons\]\r?\n^(?:.+\r?\n)*"#
        )
        .unwrap();
    };
    if icon_sources.is_empty() {
        println!("cargo::warning=No icon sources configured, skipping icon comment parsing");
        return;
    }

    let mut icons_to_apply = HashMap::<String, String>::new();
    let source_path = Path::new(source_code);

    if !source_path.exists() {
        println!(
            "cargo::warning=Source path {} does not exist, skipping icon comment parsing",
            source_code
        );
        return;
    }

    // recursively find all .rs files in source_path
    let source_files = walkdir::WalkDir::new(source_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map_or(false, |ext| ext == "rs"))
        .collect::<Vec<walkdir::DirEntry>>();

    for entry in source_files {
        let file_path = entry.path();

        let file_content = std::fs::read_to_string(file_path).unwrap_or_else(|_| {
            println!(
                "cargo::warning=Failed to read file {}, skipping",
                file_path.display()
            );
            String::new()
        });

        let icon_comment = ICON_COMMENT_REGEX.captures(&file_content);
        let icon_class = ICON_CLASS_REGEX.captures(&file_content);

        let icon_comment = match icon_comment {
            Some(caps) => caps.get(1).map_or("", |m| m.as_str()),
            None => {
                // println!("cargo::warning=No icon comment found in {}, skipping", file_path.display());
                continue;
            }
        };

        let icon_class = match icon_class {
            Some(caps) => caps.get(1).map_or("", |m| m.as_str()),
            None => {
                // println!(
                //     "cargo::warning=No struct definition found in {}, skipping",
                //     file_path.display()
                // );
                continue;
            }
        };

        // get the icon name from the resource path, eg: for res://icons/fa/coffee.svg, icon name is coffee.svg
        let icon_name = icon_comment.split('/').last().unwrap_or("");

        // check if the icon already exists in the resource path
        let icon_path = icon_comment.replace("res:/", resource_path);

        if !Path::new(resource_path).exists() {
            std::fs::create_dir_all(resource_path).unwrap_or_else(|_| {
                println!(
                    "cargo::warning=Failed to create resource path {}, skipping icon download",
                    resource_path
                );
            });
        }

        if Path::new(&icon_path).exists() {
            // TODO - maybe make this optional with a flag to always redownload, maybe only show if a --verbose flag is set
            println!("cargo::warning=Icon {} already exists, skipping", icon_path);
            icons_to_apply.insert(icon_class.to_string(), icon_path.clone());
            continue;
        }

        // find the matching icon source, eg: for res://icons/gd/circle.svg, icon source is keyed by "res://icons/gd"
        let icon_source_key = icon_sources
            .keys()
            .find(|key| icon_comment.starts_with(*key));

        if let Some(icon_source_key) = icon_source_key {
            let icon_source_url = &icon_sources[icon_source_key];

            if icon_source_url.starts_with("http") {
                let download_url = format!("{}{}", icon_source_url, icon_name);
                println!(
                    "cargo::warning=Downloading icon {} for class {} from {}",
                    icon_name, icon_class, download_url
                );

                let response = reqwest::blocking::get(&download_url);
                if response.is_err() {
                    println!(
                        "cargo::warning=Failed to download icon {} from {}, skipping",
                        icon_name, download_url
                    );
                    continue;
                }
                let response = response.unwrap();
                if !response.status().is_success() {
                    println!(
                        "cargo::warning=Failed to download icon {} from {}, status: {}, skipping",
                        icon_name,
                        download_url,
                        response.status()
                    );
                    continue;
                }

                let bytes = response.bytes();
                if bytes.is_err() {
                    println!(
                        "cargo::warning=Failed to read bytes from response for icon {}, skipping",
                        icon_name
                    );
                    continue;
                }

                let bytes = bytes.unwrap();

                // ensure the directory exists
                let icon_dir = Path::new(&icon_path).parent().unwrap();
                if !icon_dir.exists() {
                    fs::create_dir_all(icon_dir).unwrap_or_else(|_| {
                        println!(
                            "cargo::warning=Failed to create directory {} for icon {}, skipping",
                            icon_dir.display(),
                            icon_name
                        );
                    });
                }

                let mut file = fs::File::create(&icon_path).unwrap();

                match file.write_all(&bytes) {
                    Ok(_) => {
                        println!(
                            "cargo::warning=Icon {} downloaded and saved to {}",
                            icon_name, icon_path
                        );
                    }
                    Err(e) => {
                        println!(
                            "cargo::warning=Failed to write icon {} to {}, error: {}, skipping",
                            icon_name, icon_path, e
                        );
                        continue;
                    }
                }
            } else {
                // assume it's a local path, find the file and copy it to the resource path
                let local_icon_path = Path::new(icon_source_url)
                    .join(icon_name)
                    .to_string_lossy()
                    .to_string();

                println!(
                    "cargo::warning=local path {} icon source {}",
                    local_icon_path, icon_source_url
                );

                if !Path::new(&local_icon_path).exists() {
                    println!(
                        "cargo::warning=Local icon source {} does not exist, skipping",
                        local_icon_path
                    );
                    continue;
                }

                let icon_dir = Path::new(&icon_path).parent().unwrap();
                if !icon_dir.exists() {
                    fs::create_dir_all(icon_dir).unwrap_or_else(|_| {
                        println!(
                            "cargo::warning=Failed to create directory {} for icon {}, skipping",
                            icon_dir.display(),
                            icon_name
                        );
                    });
                }

                let result = fs::copy(&local_icon_path, &icon_path);
                if result.is_err() {
                    println!(
                        "cargo::warning=Failed to copy icon from {} to {}, error: {}, skipping",
                        local_icon_path,
                        icon_path,
                        result.err().unwrap()
                    );
                    continue;
                } else {
                    println!(
                        "cargo::warning=Icon {} copied from {} to {}",
                        icon_name, local_icon_path, icon_path
                    );
                }
            }

            icons_to_apply.insert(icon_class.to_string(), icon_path.clone());
        } else {
            println!(
                "cargo::warning=No icon source found for icon {}, skipping",
                icon_comment
            );
            continue;
        }
    }

    // backup the .gdextension file
    let gdext_backup_path = format!("{}.bak", gdextension_path);

    // only backup if the backup doesn't already exist - so we don't overwrite a good backup with a bad one
    if Path::new(gdextension_path).exists() && !Path::new(&gdext_backup_path).exists() {
        let result = fs::copy(gdextension_path, &gdext_backup_path);
        if result.is_err() {
            println!(
                "cargo::warning=Failed to backup .gdextension file {}, skipping icon application",
                gdextension_path
            );
            return;
        }
    } else if !Path::new(gdextension_path).exists() {
        println!(
            "cargo::error=.gdextension file {} does not exist, cannot apply icons",
            gdextension_path
        );
        return;
    }

    let gdext_content = fs::read_to_string(gdextension_path);
    if gdext_content.is_err() {
        println!(
            "cargo::error=Failed to read .gdextension file {}, skipping icon application",
            gdextension_path
        );
        return;
    }

    let mut gdext_content = gdext_content.unwrap();
    let mut icon_assignments: Vec<String> = icons_to_apply
        .iter()
        .map(|(class, path)| format!("{} = \"{}\"", class, to_resource_path(path, resource_path)))
        .collect();

    // sort assignments by class name to ensure consistent ordering
    icon_assignments.sort();

    let new_icons_section = format!(
        "; zgrcg - autogenerated icons from comments\n[icons]\n{}\n",
        icon_assignments.join("\n")
    );

    if ICONS_SECTION_REGEX.is_match(&gdext_content) {
        gdext_content = ICONS_SECTION_REGEX
            .replace(&gdext_content, new_icons_section.as_str())
            .to_string();
    } else {
        // append to the end of the file
        gdext_content = format!("{}\n\n{}", gdext_content, new_icons_section);
    }

    let result = fs::write(gdextension_path, gdext_content);
    if result.is_err() {
        println!(
            "cargo::error=Failed to write updated .gdextension file {}, error: {}",
            gdextension_path,
            result.err().unwrap()
        );
        return;
    }

    println!(
        "cargo::warning=Icons applied to .gdextension file {}",
        gdextension_path
    );
}
